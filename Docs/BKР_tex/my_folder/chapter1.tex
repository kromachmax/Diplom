\chapter{Анализ существующих алгоритмов назначения}
\label{ch:analysis}

\section{Введение в предметную область}
Задача назначения --- одна из ключевых проблем комбинаторной оптимизации, широко применяемая в робототехнике, логистике и управлении ресурсами. Согласно \cite{bertsekas1990}, задача заключается в распределении \( n \) агентов (например, роботов) по \( m \) объектам (например, задачам или целям) для максимизации суммарной выгоды, заданной матрицей \( \{a_{ij}\} \), где \( a_{ij} \) --- выгода от назначения агента \( i \) объекту \( j \). Постановка задачи в общем случае:

\[
\sum_{i=1}^n a_{i j_i} \to \max,
\]

\noindent где \( j_i \) --- объект, назначенный агенту \( i \), при условии, что каждый агент получает не более одного объекта, и каждый объект назначается не более чем одному агенту. Если \( n \neq m \), некоторые агенты или объекты могут остаться неназначенными.

В робототехнике задача назначения актуальна для распределения целей между роботами в условиях ограниченной коммуникации, когда роботы обмениваются информацией только с соседями. Такие ограничения, обусловленные топологией сети, требуют алгоритмов, эффективных в распределенных системах.

Цель главы --- проанализировать аукционный и венгерский алгоритмы, включая их математические основы, сходимость и оптимальность, а также оценить их применимость в робототехнике. Анализ обосновывает необходимость модифицированного аукционного алгоритма для ограниченной коммуникации.


\section{Аукционный алгоритм}
Аукционный алгоритм, предложенный Д. Бертсекасом \cite{bertsekas1990}, представляет собой итеративный метод для решения задачи назначения, моделирующий процесс аукциона, где роботы делают ставки на цели, а цены корректируются для достижения оптимального распределения.

\subsection{Постановка задачи}
Задача назначения заключается в нахождении оптимального соответствия между \( n \) роботами и \( m \) целями с учетом матрицы выгод \( \{a_{ij}\} \), где \( a_{ij} \) --- выгода робота \( i \) при назначении ему цели \( j \). Цель --- максимизировать суммарную выгоду:

\[
\max \sum_{i=1}^n a_{i j_i},
\]

\noindent где \( j_i \) --- цель, назначенная роботу \( i \), при условии, что каждый робот получает не более одной цели, и каждая цель назначается не более чем одному роботу. Эта задача эквивалентна задаче линейного программирования:

\[
\begin{aligned}
&\max \sum_{i=1}^n \sum_{j=1}^m a_{ij} x_{ij}, \\
&\text{при ограничениях:} \\
&\sum_{i=1}^n x_{ij} \leq 1, \quad \forall j = 1, \ldots, m, \\
&\sum_{j=1}^m x_{ij} \leq 1, \quad \forall i = 1, \ldots, n, \\
&x_{ij} \in \{0, 1\}, \quad \forall i, j,
\end{aligned}
\]

\noindent где \( x_{ij} = 1 \), если робот \( i \) назначен цели \( j \), и \( x_{ij} = 0 \) в противном случае. Аукционный алгоритм решает эту задачу приближенно, обеспечивая суммарную выгоду, которая, согласно \cite{bertsekas1990}, находится в пределах \( \min(n, m) \varepsilon \) от оптимального значения, где \( \varepsilon > 0 \) --- параметр точности, определяющий степень приближения. Это означает, что если \( A^* \) --- оптимальная выгода, а \( A \) --- выгода, полученная алгоритмом, то:

\[
A^* - \min(n, m) \varepsilon \leq A \leq A^*.
\]

Для целочисленных \( a_{ij} \) и \( \varepsilon < 1/\min(n, m) \), алгоритм гарантирует точное оптимальное решение.

\subsection{Описание алгоритма}
Согласно \cite{bertsekas1990}, аукционный алгоритм работает с матрицей выгод \( \{a_{ij}\} \), где \( a_{ij} \) — выгода робота \( i \) при назначении цели \( j \), и использует цены \( \{p_j\} \), где \( p_j \geq 0 \) — цена, связанная с целью \( j \), отражающая текущую стоимость ее назначения и регулирующая конкуренцию между роботами. Алгоритм начинается с произвольного распределения роботов по целям (возможно, пустого) и начальных цен \( \{p_j\} \), обычно равных нулю. Ключевые определения:

\begin{itemize}
    \item \textit{Почти счастье}: Робот \( i \), назначенный цели \( j_i \), почти счастлив, если:

    \[
    a_{i j_i} - p_{j_i} \geq \max_{j=1,\ldots,m} \{a_{ij} - p_j\} - \varepsilon,
    \]

    где \( \varepsilon > 0 \) — параметр точности.
    \item \textit{Почти равновесие}: Распределение и цены, при которых все назначенные роботы почти счастливы.
\end{itemize}

Шаги алгоритма \cite{bertsekas1990}:

\begin{enumerate}
    \item Проверить, все ли назначенные роботы почти счастливы. Если да, завершить.
    \item Выбрать робота \( i \), не почти счастливого (или неназначенного), и найти цель \( j_i \):

    \[
    j_i \in \arg \max_{j=1,\ldots,m} \{a_{ij} - p_j\}.
    \]

    \item Переназначить: робот \( i \) получает цель \( j_i \), а робот, ранее назначенный на \( j_i \), получает цель, принадлежавшую \( i \), или остается неназначенным.
    \item Увеличить цену \( p_{j_i} \) на:

    \[
    \gamma_i = v_i - w_i + \varepsilon,
    \]

    где \( v_i = \max_{j=1,\ldots,m} \{a_{ij} - p_j\} \), \( w_i = \max_{j \neq j_i} \{a_{ij} - p_j\} \).
    \item Повторить с шага 1.
\end{enumerate}

\subsection{Сходимость алгоритма}
\begin{theorem}[Сходимость аукционного алгоритма \cite{bertsekas1990}]
\label{thm:auction_convergence}
Для произвольных \( n \) роботов и \( m \) целей аукционный алгоритм завершается за конечное число шагов с распределением и ценами, при которых каждый назначенный робот получает уникальную цель и является почти счастливым, а неназначенные роботы возможны только при \( n > m \).
\end{theorem}

\textbf{Доказательство}. Аукционный алгоритм итеративно назначает цели роботам, корректируя цены \( \{p_j\} \). Робот \( i \), назначенный цели \( j_i \), почти счастлив, если:

\[
a_{i j_i} - p_{j_i} \geq \max_{j=1,\ldots,m} \{a_{ij} - p_j\} - \varepsilon,
\]

\noindent где \( \varepsilon > 0 \) — параметр точности. На каждой итерации алгоритм выбирает робота \( i \), который либо неназначен, либо не почти счастлив, и определяет цель \( j_i \), максимизирующую:

\[
j_i \in \arg \max_{j=1,\ldots,m} \{a_{ij} - p_j\},
\]

\noindent увеличивая цену \( p_{j_i} \) на:

\[
\gamma_i = v_i - w_i + \varepsilon, \quad \text{где} \quad v_i = \max_{j=1,\ldots,m} \{a_{ij} - p_j\}, \quad w_i = \max_{j \neq j_i} \{a_{ij} - p_j\}.
\]

\noindent Робот \( i \) назначается цели \( j_i \), становясь почти счастливым, так как:

\[
a_{i j_i} - (p_{j_i} + \gamma_i) = a_{i j_i} - p_{j_i} - (v_i - w_i + \varepsilon) = w_i - \varepsilon \geq \max_{j \neq j_i} \{a_{ij} - p_j\} - \varepsilon.
\]

Если цель \( j_i \) уже была назначена роботу \( k \), то \( k \) становится неназначенным, а \( i \) получает \( j_i \). Это обеспечивает уникальность назначений: каждая цель назначается не более чем одному роботу.

Алгоритм продолжает итерации, пока существуют неназначенные или не почти счастливые роботы. На каждой итерации неназначенный робот \( i \) выбирает цель \( j_i \), увеличивая ее цену на \( \gamma_i \geq \varepsilon \). Если \( j_i \) занята роботом \( k \), то \( k \) становится неназначенным и в следующей итерации выбирает новую цель. Цены \( p_j \) монотонно возрастают, что делает уже назначенные цели менее привлекательными для неназначенных роботов, так как \( a_{ij} - p_j \) уменьшается с ростом \( p_j \).

Если цель \( j \) получила много ставок, ее цена \( p_j \geq m' \varepsilon \), где \( m' \) — число ставок. При большом \( p_j \), \( a_{ij} - p_j \) становится меньше, чем \( a_{ik} - p_k \) для цели \( k \) с низкой ценой (например, \( p_k = 0 \), если \( k \) не получала ставок). Таким образом, неназначенные роботы предпочитают цели с низкими ценами, которые часто свободны или менее востребованы. Поскольку рост цен ограничен (максимум \( C + \varepsilon \), где \( C = \max_{i,j} |a_{ij}| \), так как \( a_{ij} - p_j < 0 \) невыгодно), число ставок на конкретную цель конечно, и далее, после какого-то порогового значения цены, она не будет выбираться другими роботами.

При \( n \leq m \), алгоритм стремится назначить каждому из \( n \) роботов уникальную цель, так как целей достаточно. Итерации продолжаются, пока все роботы не станут почти счастливыми, что возможно, так как число целей \( m \geq n \). Когда все \( n \) роботов назначены и почти счастливы, алгоритм завершается. При \( n > m \), максимум \( m \) роботов могут быть назначены, так как целей только \( m \). В этом случае после назначения \( m \) целей неназначенные \( n - m \) роботы остаются без целей, и алгоритм завершается, так как все назначенные роботы почти счастливы, а неназначенным роботам не хватает целей для новых назначений. Уникальность назначений сохраняется на всех итерациях, так как переназначение освобождает цель ровно для одного робота.

Число итераций конечно из-за конечности \( n \), \( m \) и ограниченности роста цен. Таким образом, алгоритм завершается за конечное число шагов, обеспечивая, что каждый назначенный робот получает уникальную цель и является почти счастливым, а неназначенные роботы возможны только при \( n > m \).

\begin{theorem}[Оценка числа итераций аукционного алгоритма]
\label{thm:auction_iterations}
Количество итераций аукционного алгоритма в худшем случае равно \( \frac{m \cdot C}{\varepsilon} \), где \( m \) — число целей, \( C = \max_{i,j} |a_{ij}| \) — максимальная абсолютная величина выгоды от назначения робота на цель, а \( \varepsilon \) — минимальный шаг увеличения цены цели в алгоритме.
\end{theorem}

\textbf{Доказательство.}  
В аукционном алгоритме задача назначения включает \( n \) роботов и \( m \) целей, где каждому роботу должна быть назначена ровно одна цель. На каждой итерации алгоритма один робот делает ставку на цель, увеличивая её цену как минимум на \( \varepsilon \). Элементы матрицы выгод \( a_{ij} \) представляют выгоду от назначения робота \( i \) на цель \( j \), и максимальная возможная выгода ограничена величиной \( C = \max_{i,j} |a_{ij}| \). 

В худшем случае, когда начальные цены целей равны нулю, а алгоритм требует достижения цен порядка \( C \) для всех \( m \) целей, чтобы обеспечить оптимальное распределение, каждая цель может потребовать до \( C / \varepsilon \) итераций для достижения своей предельной цены. Поскольку в задаче участвуют \( m \) целей, общее количество итераций в худшем случае составляет \( m \cdot C / \varepsilon \).

\subsection{Оптимальность}
\begin{theorem}[Оптимальность аукционного алгоритма \cite{bertsekas1990}]
\label{thm:auction_optimality}
Если алгоритм завершается с почти равновесным распределением, суммарная выгода находится в пределах \( \min(n, m) \varepsilon \) от оптимальной. При целочисленных \( a_{ij} \) и \( \varepsilon < 1/\min(n, m) \), распределение оптимально.
\end{theorem}

\textbf{Доказательство}. Оптимальная выгода:

\[
A^* = \max_{\{k_i\}} \sum_{i=1}^n a_{i k_i}, \quad k_i \neq k_l \text{ для } l \neq i, \text{ где } k_i \in \{1, \ldots, m\}.
\]

Двойственная задача:

\[
D^* = \min_{p_j} \left\{ \sum_{j=1}^m p_j + \sum_{i=1}^n \max_j \{a_{ij} - p_j\} \right\}.
\]

Для любого распределения \( \{ (i, k_i) \} \) и цен \( \{ p_j \} \):

\[
\sum_{i=1}^n a_{i k_i} \leq \sum_{j=1}^m p_j + \sum_{i=1}^n \max_j \{a_{ij} - p_j\},
\]

так как \( \max_j \{a_{ij} - p_j\} \geq a_{i k_i} - p_{k_i} \). Следовательно, \( A^* \leq D^* \).

При почти равновесии для распределения \( \{ (i, j_i) \} \):

\[
a_{i j_i} - p_{j_i} \geq \max_j \{a_{ij} - p_j\} - \varepsilon.
\]

Суммируем по \( i \) для назначенных роботов:

\[
\sum_{i=1}^{\min(n, m)} (a_{i j_i} - p_{j_i}) \geq \sum_{i=1}^n \max_j \{a_{ij} - p_j\} - \min(n, m) \varepsilon.
\]

Добавим \( \sum_{j=1}^m p_j \):

\[
\sum_{i=1}^{\min(n, m)} a_{i j_i} \geq \sum_{j=1}^m p_j + \sum_{i=1}^n \max_j \{a_{ij} - p_j\} - \min(n, m) \varepsilon.
\]

Поскольку \( D^* \leq \sum_{j=1}^m p_j + \sum_{i=1}^n \max_j \{a_{ij} - p_j\} \), то:

\[
\sum_{i=1}^{\min(n, m)} a_{i j_i} \geq D^* - \min(n, m) \varepsilon \geq A^* - \min(n, m) \varepsilon.
\]

Так как \( \sum_{i=1}^{\min(n, m)} a_{i j_i} \leq A^* \), получаем:

\[
A^* - \min(n, m) \varepsilon \leq \sum_{i=1}^{\min(n, m)} a_{i j_i} \leq A^*.
\]

Для целочисленных \( a_{ij} \) и \( \varepsilon < 1/\min(n, m) \), \( A^* - \sum_{i=1}^{\min(n, m)} a_{i j_i} < 1 \), и, так как разность целочисленная, \( A^* = \sum_{i=1}^{\min(n, m)} a_{i j_i} \).

\subsection{Преимущества и недостатки}
Преимущества:
\begin{itemize}
    \item Интуитивная экономическая модель: алгоритм имитирует реальный аукцион, упрощая понимание и интерпретацию.
    \item Гибкость для адаптации: легко модифицируется для асимметричных задач с \( n \neq m \), транспортных проблем и задач минимальной стоимости потока \cite{bertsekas1990}.
    \item Хорошо подходит для параллельных и распределенных систем: допускает асинхронные и параллельные реализации, эффективен для разреженных задач \cite{gerkey2003}.
\end{itemize}

Недостатки:
\begin{itemize}
    \item Число итераций зависит от \( C / \varepsilon \): для больших \( C = \max_{i,j} |a_{ij}| \) и малого \( \varepsilon \) требует большого числа итераций.
    \item Чувствительность к выбору \( \varepsilon \): большое \( \varepsilon \) снижает точность, малое \( \varepsilon \) увеличивает число итераций.
    \item Чувствительность к начальным ценам: плохие начальные цены замедляют сходимость, хотя \( \varepsilon \)-масштабирование смягчает эту проблему.
\end{itemize}

\section{Венгерский алгоритм}
Венгерский алгоритм, разработанный Х. Куном \cite{kuhn1955}, решает задачу назначения через редукцию матрицы выгод или эквивалентную задачу максимального паросочетания в двудольном графе \cite{emaxx2025}.

\subsection{Матричный подход}
Алгоритм работает с матрицей выгод \( \{a_{ij}\} \) размера \( n \times m \). Для унификации, если \( n \neq m \), матрица дополняется фиктивными роботами или целями с нулевой выгодой, чтобы получить квадратную матрицу размера \( \max(n, m) \times \max(n, m) \) \cite{kuhn1955}:

\begin{enumerate}
    \item Для каждого ряда вычесть минимальный элемент: \( a_{ij} \gets a_{ij} - \min_j a_{ij} \).
    \item Для каждого столбца вычесть минимальный элемент: \( a_{ij} \gets a_{ij} - \min_i a_{ij} \).
    \item Найти минимальное число строк и столбцов, покрывающих все нули.
    \item Если число линий равно \( \min(n, m) \), найти назначение (нули соответствуют оптимальным парам) и завершить.
    \item Иначе найти минимальный непокрытый элемент \( \delta \), вычесть \( \delta \) из непокрытых элементов, прибавить к элементам на пересечении линий, вернуться к шагу 3.
\end{enumerate}

\subsection{Графовый подход}
Как указано в \cite{emaxx2025}, задача назначения эквивалентна нахождению максимального паросочетания в двудольном графе \( G = (V_1 \cup V_2, E) \), где \( V_1 \) --- роботы (\( n \) вершин), \( V_2 \) --- цели (\( m \) вершин), а ребра \( (i,j) \) имеют вес \( a_{ij} \). Алгоритм:

\begin{enumerate}
    \item Построить матрицу \( \{a_{ij}\} \) и редуцировать ее, как выше.
    \item Сформировать граф, где ребра соответствуют нулям в матрице.
    \item Найти максимальное паросочетание (например, с помощью алгоритма Куна или Форда-Фалкерсона).
    \item Если паросочетание покрывает \( \min(n, m) \) вершин, оно оптимально. Иначе корректировать матрицу (\( \delta \)) и обновить граф.
\end{enumerate}

\subsection{Доказательство оптимальности}
Алгоритм основан на двойственности линейного программирования \cite{kuhn1955}. Примитивная задача:

\[
\max \sum_{i,j} a_{ij} x_{ij}, \quad \sum_{j=1}^m x_{ij} \leq 1, \sum_{i=1}^n x_{ij} \leq 1, x_{ij} \geq 0.
\]

Двойственная задача:

\[
\min \sum_{i=1}^n u_i + \sum_{j=1}^m v_j, \quad u_i + v_j \geq a_{ij},
\]

\noindent где \( u_i \), \( v_j \) --- двойственные переменные. Редукция матрицы и корректировка \( \delta \) обеспечивают выполнение условий \( u_i + v_j \geq a_{ij} \), а равенство \( u_i + v_j = a_{ij} \) для выбранных пар дает оптимальность.

\subsection{Преимущества и недостатки}
Преимущества:
\begin{itemize}
    \item Гарантированная оптимальность.
    \item Простота реализации \cite{emaxx2025}.
\end{itemize}

Недостатки:
\begin{itemize}
    \item Сложность \( O(n^2*m) \) для больших \( n \) или \( m \).
    \item Требует полной матрицы \( \{a_{ij}\} \), что проблематично при ограниченной коммуникации.
    \item Непригодность для распределенных систем: невозможность работы в условиях ограниченной коммуникации между роботами, так как алгоритм предполагает централизованное управление \cite{kalyaev2009}.
    \item Не допускает асинхронных и параллельных реализаций.
\end{itemize}

\section{Постановка проблемы}
В распределенных системах с \( n \) роботами и \( m \) целями часто возникают ограниченные области связи, при которых каждый робот видит все цели, но не может обмениваться информацией с другими роботами \cite{kalyaev2009},\cite{gerkey2003}. Аукционный алгоритм \cite{bertsekas1990} предполагает, что роботы могут координировать назначения через обмен информацией, что невозможно в условиях отсутствия коммуникации между роботами. Это приводит к необходимости дополнительных механизмов координации или снижению качества назначений. Венгерский алгоритм \cite{kuhn1955} требует полной матрицы выгод и централизованного управления, что неосуществимо в таких системах \cite{kalyaev2009}. Необходим модифицированный аукционный алгоритм, который:

\begin{itemize}
    \item Учитывает отсутствие полной коммуникации между \( n \) роботами.
    \item Обеспечивает эффективность и близость к оптимальности.
\end{itemize}

Цель --- разработать такой алгоритм и сравнить его с венгерским методом.

\section{Выводы}
Рассмотрены аукционный \cite{bertsekas1990} и венгерский \cite{kuhn1955} алгоритмы для задачи назначения \( n \) роботов по \( m \) целям. Аукционный алгоритм эффективен, но требует адаптации для условий, где не все роботы могут обмениваться информацией друг с другом. Венгерский алгоритм оптимален, но непригоден для распределенных систем без централизации. Необходим модифицированный аукционный алгоритм, учитывающий отсутствие коммуникации между роботами.


