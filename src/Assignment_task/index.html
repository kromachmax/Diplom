<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Визуализация назначений роботов на задачи</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #controls {
            padding: 10px;
            background-color: #f0f0f0;
            text-align: center;
            flex-shrink: 0;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            font-size: 14px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        #status {
            font-size: 14px;
            color: #333;
            margin: 5px 0;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }
        #auctionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="toggleMode('robot')">Добавить робота</button>
        <button onclick="toggleMode('task')">Добавить задачу</button>
        <button onclick="clearCanvas()">Очистить</button>
        <button onclick="runAlgorithm()">Запустить алгоритм</button>
        <div id="status">Режим: Добавление роботов</div>
    </div>
    <div id="canvas-container">
        <div id="auctionCanvas"></div>
    </div>
    <script>
        let robot_coords = [];
        let task_coords = [];
        let assignment = [];
        let mode = 'robot';
        let animProgress = 0;
        const ANIM_DURATION = 30;
        let visibilityRadius = 15.0;

        let sketch = function(p) {
            p.setup = function() {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight - document.getElementById('controls').offsetHeight);
                canvas.parent('auctionCanvas');
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(12);
                p.frameRate(60);
            };

            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, p.windowHeight - document.getElementById('controls').offsetHeight);
            };

            p.mousePressed = function() {
                if (p.mouseY > document.getElementById('controls').offsetHeight && p.mouseX >= 0 && p.mouseX < p.width && p.mouseY < p.height) {
                    const margin = Math.min(p.width, p.height) * 0.05;
                    const scaleX = (p.width - 2 * margin) / 100;
                    const scaleY = (p.height - 2 * margin) / 100;
                    const x = (p.mouseX - margin) / scaleX;
                    const y = (p.mouseY - margin) / scaleY;
                    if (mode === 'robot') {
                        robot_coords.push([x, y]);
                        document.getElementById('status').textContent = `Добавлен робот ${robot_coords.length - 1} в (${x.toFixed(2)}, ${y.toFixed(2)})`;
                    } else {
                        task_coords.push([x, y]);
                        document.getElementById('status').textContent = `Добавлена задача ${task_coords.length - 1} в (${x.toFixed(2)}, ${y.toFixed(2)})`;
                    }
                    assignment = [];
                }
            };

            p.draw = function() {
                p.background(255);

                const margin = Math.min(p.width, p.height) * 0.05;
                const scaleX = (p.width - 2 * margin) / 100;
                const scaleY = (p.height - 2 * margin) / 100;
                const scale = Math.min(scaleX, scaleY); // Единый масштаб для окружностей

                for (let i = 0; i < robot_coords.length; i++) {
                    let x = margin + robot_coords[i][0] * scaleX;
                    let y = margin + robot_coords[i][1] * scaleY;
                    p.noFill();
                    p.stroke(100, 100, 255, 100);
                    p.strokeWeight(1);
                    p.ellipse(x, y, visibilityRadius * scale * 2, visibilityRadius * scale * 2);
                }

                for (let i = 0; i < robot_coords.length; i++) {
                    let x = margin + robot_coords[i][0] * scaleX;
                    let y = margin + robot_coords[i][1] * scaleY;
                    p.fill(100, 100, 255);
                    p.noStroke();
                    p.ellipse(x, y, 15, 15);
                    p.fill(0);
                    p.text(`R${i}`, x, y + 25);
                }

                for (let j = 0; j < task_coords.length; j++) {
                    let x = margin + task_coords[j][0] * scaleX;
                    let y = margin + task_coords[j][1] * scaleY;
                    p.fill(255, 100, 100);
                    p.noStroke();
                    p.rect(x - 10, y - 10, 20, 20);
                    p.fill(0);
                    p.text(`T${j}`, x, y + 25);
                }

                if (assignment.length > 0) {
                    p.stroke(0, 150, 0);
                    p.strokeWeight(2);
                    for (let i = 0; i < robot_coords.length; i++) {
                        if (assignment[i] >= 0 && assignment[i] < task_coords.length) {
                            let startX = margin + robot_coords[i][0] * scaleX;
                            let startY = margin + robot_coords[i][1] * scaleY;
                            let endX = margin + task_coords[assignment[i]][0] * scaleX;
                            let endY = margin + task_coords[assignment[i]][1] * scaleY;
                            let t = Math.min(animProgress / ANIM_DURATION, 1);
                            let interpX = startX + (endX - startX) * t;
                            let interpY = startY + (endY - startY) * t;
                            p.line(startX, startY, interpX, interpY);
                        }
                    }
                    p.noStroke();
                }
            };
        };

        new p5(sketch, 'auctionCanvas');

        function toggleMode(newMode) {
            mode = newMode;
            document.getElementById('status').textContent = `Режим: Добавление ${mode === 'robot' ? 'роботов' : 'задач'}`;
        }

        function clearCanvas() {
            robot_coords = [];
            task_coords = [];
            assignment = [];
            document.getElementById('status').textContent = `Поле очищено. Режим: Добавление ${mode === 'robot' ? 'роботов' : 'задач'}`;
        }

        function runAlgorithm() {
            if (robot_coords.length === 0 || task_coords.length === 0) {
                document.getElementById('status').textContent = 'Ошибка: Добавьте хотя бы одного робота и одну задачу';
                return;
            }

            const data = {
                n: robot_coords.length,
                m: task_coords.length,
                robot_coords: robot_coords,
                task_coords: task_coords
            };

            document.getElementById('status').textContent = 'Отправка данных на сервер...';

            fetch('http://localhost:8000/run_auction', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(response => {
                if (!response.ok) throw new Error('Ошибка сервера');
                return response.json();
            })
            .then(data => {
                assignment = data.assignment;
                visibilityRadius = data.visibility_radius || 15.0;
                animProgress = 0;
                document.getElementById('status').textContent = `Получены назначения. Полезность: ${data.utility.toFixed(2)}`;
                console.log('Назначения:', assignment);
                console.log('Радиус видимости:', visibilityRadius);
            })
            .catch(error => {
                document.getElementById('status').textContent = 'Ошибка: ' + error.message;
                console.error('Ошибка:', error);
            });
        }

        setInterval(() => {
            if (animProgress < ANIM_DURATION) {
                animProgress++;
            }
        }, 1000 / 60);
    </script>
</body>
</html>
